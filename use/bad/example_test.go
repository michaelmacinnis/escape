package main

import (
	"testing"

	"github.com/michaelmacinnis/escape/use/errors"
)

var errFailure = errors.New("failure")

func cannotPassToParent() (err error) {
	check := func() func(error) {
		var escape_hatch_1 func(error)
		{
			p := &err

			panicking := false

			escape_hatch_1 = func(v error) { // generated by escape: example_test.ego:13:34
				*p = v

				if !panicking {
					panicking = true
					panic(&panicking)
				}
			}

			defer func() {
				if panicking {
					panicking = false

					r := recover()
					if r != &panicking {
						// It would be better if we could unrecover.
						// Or if panicking with the return value from recover, unrecovered.
						// Or if there was a mechanism specifically for this that did not
						// use panic/recover but was weaker than panic in the same way that
						// panic is weaker than runtime.Goexit.
						panic(r)
					}
				}
			}()
		}
		f := errors.Check(escape_hatch_1)
		return f
	}()

	check(failure())

	return
}

func cannotPassToParent2() (err error) {
	var check func(error)

	func() {
		var escape_hatch_2 func(error)
		{
			p := &err

			panicking := false

			escape_hatch_2 = func(v error) { // generated by escape: example_test.ego:26:31
				*p = v

				if !panicking {
					panicking = true
					panic(&panicking)
				}
			}

			defer func() {
				if panicking {
					panicking = false

					r := recover()
					if r != &panicking {
						// It would be better if we could unrecover.
						// Or if panicking with the return value from recover, unrecovered.
						// Or if there was a mechanism specifically for this that did not
						// use panic/recover but was weaker than panic in the same way that
						// panic is weaker than runtime.Goexit.
						panic(r)
					}
				}
			}()
		}
		check = errors.Check(escape_hatch_2)
	}()

	check(failure())

	return
}

func cannotPassToAnotherGoroutine() (err error) {
	var check func(error)

	c := make(chan struct{})

	go func() {
		var escape_hatch_3 func(error)
		{
			p := &err

			panicking := false

			escape_hatch_3 = func(v error) { // generated by escape: example_test.ego:40:31
				*p = v

				if !panicking {
					panicking = true
					panic(&panicking)
				}
			}

			defer func() {
				if panicking {
					panicking = false

					r := recover()
					if r != &panicking {
						// It would be better if we could unrecover.
						// Or if panicking with the return value from recover, unrecovered.
						// Or if there was a mechanism specifically for this that did not
						// use panic/recover but was weaker than panic in the same way that
						// panic is weaker than runtime.Goexit.
						panic(r)
					}
				}
			}()
		}
		check = errors.Check(escape_hatch_3)

		close(c)
	}()

	<-c

	childCallsCheck(check)

	return
}

func childCallsCheck(check func(error)) {
	check(success())
	check(failure())
}

func failure() error {
	return errFailure
}

func panics(t *testing.T, f func()) {
	defer func() {
		r := recover()
		if r == nil {
			t.Errorf("The code did not panic")
		}
	}()

	f()
}

func success() error {
	return nil
}

func TestCannotPassToParent(t *testing.T) {
	panics(t, func() {
		cannotPassToParent()
	})
}

func TestCannotPassToParent2(t *testing.T) {
	panics(t, func() {
		cannotPassToParent2()
	})
}

func TestCannotPassToAnotherGoroutine(t *testing.T) {
	panics(t, func() {
		cannotPassToAnotherGoroutine()
	})
}
