package main

import (
	"errors"
	"fmt"
	"testing"
)

func annotate(abort func(error)) func(error, string, ...interface{}) {
	return func(err error, format string, args ...interface{}) {
		if err != nil {
			abort(fmt.Errorf(format+": %w", append(args, err)...))
		}
	}
}

func additionalContext() (err error) {
	var escape_hatch_1 func(error)
	{
		p := &err

		panicking := false

		escape_hatch_1 = func(v error) { // generated by escape: annotate_test.ego:18:27
			*p = v

			if !panicking {
				panicking = true
				panic(&panicking)
			}
		}

		defer func() {
			if panicking {
				panicking = false

				r := recover()
				if r != &panicking {
					// It would be better if we could unrecover.
					// Or if panicking with the return value from recover, unrecovered.
					// Or if there was a mechanism specifically for this that did not
					// use panic/recover but was weaker than panic in the same way that
					// panic is weaker than runtime.Goexit.
					panic(r)
				}
			}
		}()
	}
	check := annotate(escape_hatch_1)

	check(errors.New("reason"), "call failed")

	return
}

func TestAdditionalErrors(t *testing.T) {
	err := additionalContext()

	if err == nil || err.Error() != "call failed: reason" {
		t.Errorf("no wrapped error")
	}
}
