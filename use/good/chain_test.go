package main

import (
	"testing"
)

func furtherComplicatedChain(found func(string)) {
	found("needle")
}

func someComplicatedChain(found func(string)) {
	furtherComplicatedChain(found)
}

func notJustForErrors() (response string) {
	var escape_hatch_1 func(string)
	{
		p := &response

		panicking := false

		escape_hatch_1 = func(v string) { // generated by escape: chain_test.ego:16:21
			*p = v

			if !panicking {
				panicking = true
				panic(&panicking)
			}
		}

		defer func() {
			if panicking {
				panicking = false

				r := recover()
				if r != &panicking {
					// It would be better if we could unrecover.
					// Or if panicking with the return value from recover, unrecovered.
					// Or if there was a mechanism specifically for this that did not
					// use panic/recover but was weaker than panic in the same way that
					// panic is weaker than runtime.Goexit.
					panic(r)
				}
			}
		}()
	}
	found := escape_hatch_1

	someComplicatedChain(found)

	return "not found"
}

func TestChain(t *testing.T) {
	if notJustForErrors() != "needle" {
		t.Errorf("didn't find needle")
	}
}
