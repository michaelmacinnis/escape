package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"os"

	"github.com/dave/dst"
	"github.com/dave/dst/decorator"
)

var inline = `package generated

func unused() {
	var %s func(%s)
	{
		p := %s

		panicking := false

		%s = func(v %s) { // generated by escape: %s
			*p = v

			if !panicking {
				panicking = true
				panic(&panicking)
			}
		}

		defer func() {
			if panicking {
				panicking = false

				r := recover()
				if r != &panicking {
					// It would be better if we could unrecover.
					// Or not have to use panic/recover.
					panic(r)
				}
			}
		}()
	}
}
`

func code(d *decorator.Decorator, fset *token.FileSet, label, param, src, typ string) []dst.Stmt {
	text := fmt.Sprintf(inline, label, typ, param, label, typ, src)
	g, err := parser.ParseFile(fset, "", text, parser.ParseComments)
	if err != nil {
		return nil
	}

	generated, err := d.DecorateFile(g)
	if err != nil {
		return nil
	}

	statements := generated.Decls[0].(*dst.FuncDecl).Body.List[:2]

	statements[0] = dst.Clone(statements[0]).(dst.Stmt)
	statements[1] = dst.Clone(statements[1]).(dst.Stmt)

	return statements
}

var count = 0

func gensym() string {
	count++
	return fmt.Sprintf("escape_hatch_%d", count)
}

func find(d *decorator.Decorator, fset *token.FileSet, info *types.Info, e *dst.Expr) (label, param, src, typ string) {
	call, ok := (*e).(*dst.CallExpr)
	if !ok {
		return
	}

	ident, ok := call.Fun.(*dst.Ident)
	if !ok {
		return
	}

	if ident.Name != "escape" {
		for i := range call.Args {
			label, param, src, typ = find(d, fset, info, &call.Args[i])
			if label != "" {
				return
			}
		}

		return
	}

	if len(call.Args) != 1 {
		fmt.Fprintf(os.Stderr, "escape expects 1 argument, passed %d\n", len(call.Args))
		return
	}

	ae := d.Map.Ast.Nodes[call.Args[0]].(ast.Expr)

	src = fset.Position(ae.Pos()).String()

	t := info.Types[ae].Type

	pt, ok := t.(*types.Pointer)
	if !ok {
		fmt.Fprintf(os.Stderr, "escape expects pointer type, passed %s\n", t)
		return
	}

	typ = pt.Elem().String()

	buf := bytes.Buffer{}
	err := format.Node(&buf, fset, ae)
	if err != nil {
		return
	}

	param = buf.String()

	label = gensym()

	*e = dst.NewIdent(label)

	return
}

func replace(d *decorator.Decorator, fset *token.FileSet, file *dst.File, info *types.Info, l []dst.Stmt) []dst.Stmt {
	var head, tail []dst.Stmt

	for i, s := range l {
		assign, ok := s.(*dst.AssignStmt)
		if !ok {
			continue
		}

		if len(assign.Lhs) > 1 {
			continue
		}

		label, param, src, typ := find(d, fset, info, &assign.Rhs[0])
		if label == "" {
			continue
		}

		head = l[:i]
		tail = l[i:]

		//	insert:
		adding := code(d, fset, label, param, src, typ)
		if adding == nil {
			continue
		}

		list := make([]dst.Stmt, 0, len(l)+2)

		copy(list, head)
		list = append(list, adding[0], adding[1], tail[0])

		l = append(list, replace(d, fset, file, info, tail[1:])...)

		break
	}

	return l
}

func translate(name string) error {
	fset := token.NewFileSet()

	f, err := parser.ParseFile(fset, name, nil, parser.ParseComments)
	if err != nil {
		return err //nolint:wrapcheck
	}

	d := decorator.NewDecorator(fset)

	file, err := d.DecorateFile(f)
	if err != nil {
		return err //nolint:wrapcheck
	}

	conf := types.Config{Importer: importer.Default()}
	conf.Error = func(e error) {
		te, ok := e.(types.Error)
		if !ok || te.Msg != "undeclared name: escape" {
			err = e
		}
	}

	info := &types.Info{Types: make(map[ast.Expr]types.TypeAndValue)}

	conf.Check(name, fset, []*ast.File{f}, info)

	if err != nil {
		return err //nolint:wrapcheck
	}

	_ = info

	dst.Inspect(file, func(n dst.Node) bool {
		b, ok := n.(*dst.BlockStmt)
		if !ok {
			return true
		}

		b.List = replace(d, fset, file, info, b.List)

		return true
	})

	err = decorator.Print(file)
	if err != nil {
		return err //nolint:wrapcheck
	}

	return nil
}

func main() {
	if len(os.Args) != 2 {
		fmt.Fprintf(os.Stderr, "usage: %s FILE\n", os.Args[0])
		return
	}

	err := translate(os.Args[1])
	if err != nil {
		fmt.Fprintf(os.Stderr, "%s: %s\n", os.Args[0], err.Error())
	}
}
